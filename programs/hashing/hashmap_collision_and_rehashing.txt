https://www.youtube.com/watch?v=VsbSZwTekoE&t=246s

HASHMAP INTERNAL WORKING â€“ COMPLETE NOTES (JAVA)

----------------------------------------------------
1) WHAT IS HASHMAP?
----------------------------------------------------
- HashMap is a Map implementation in Java.
- Stores data as Keyâ€“Value pairs.
- Keys must be unique.
- Values can be duplicated.
- Not thread-safe.
- Does NOT maintain insertion order.

----------------------------------------------------
2) INTERNAL DATA STRUCTURE
----------------------------------------------------
- Internally, HashMap uses an array of buckets:

    Node<K, V>[] table;

- Each bucket stores exactly ONE of the following:
    - Linked List (Java 7)
    - Linked List or Red-Black Tree (Java 8+)

Each Node contains:
    - int hash
    - K key
    - V value
    - Node<K,V> next

----------------------------------------------------
3) HASHCODE AND EQUALS (VERY IMPORTANT)
----------------------------------------------------
- hashCode():
    Used to determine the bucket index.

- equals():
    Used to compare keys within the same bucket.

Rules:
- Same hashCode â†’ equals() is checked
- equals() == true â†’ value is replaced
- equals() == false â†’ collision â†’ new node added

----------------------------------------------------
4) HOW BUCKET INDEX IS CALCULATED
----------------------------------------------------
Java 8+ calculation:

    index = hash & (capacity - 1)

Example:
Capacity = 8
capacity - 1 = 7 (binary: 0111)

Key = 9
hashCode(9) = 9 (binary: 1001)

index = 1001 & 0111 = 0001 = 1

----------------------------------------------------
5) COLLISION HANDLING (CHAINING)
----------------------------------------------------
Collision:
- When multiple keys map to the same bucket index.

Example Keys:
    1, 9, 17

Capacity = 8

Index calculation:
    1  & 7 = 1
    9  & 7 = 1
    17 & 7 = 1

Bucket 1:
    1 â†’ 9 â†’ 17

Important:
- Each bucket has ONLY ONE linked list.
- That linked list stores multiple KEYâ€“VALUE pairs.

Java 8+ Optimization:
- If a bucket has > 8 nodes
- AND capacity â‰¥ 64
â†’ Linked List converts to Red-Black Tree.

----------------------------------------------------
6) DEFAULT CAPACITY AND LOAD FACTOR
----------------------------------------------------
Default Capacity: 16
Default Load Factor: 0.75

Threshold:
    threshold = capacity Ã— loadFactor

Example:
    16 Ã— 0.75 = 12

Resize condition:
    size > threshold

----------------------------------------------------
7) RESIZING (REHASHING) â€“ CORRECT LOGIC
----------------------------------------------------
IMPORTANT:
- Resizing is triggered by SIZE, NOT by collisions.

When resizing:
- Capacity doubles.
- HashCode is NOT recalculated.
- Bit logic is used for redistribution.

Rule:
    New index is either:
        oldIndex
        OR
        oldIndex + oldCapacity

Example:
Old Capacity = 8
New Capacity = 16

Keys in Bucket 6:
    6, 14, 22, 30

Binary decision:
    6  & 8  = 0 â†’ stays at 6
    14 & 8  = 8 â†’ moves to 14
    22 & 8  = 0 â†’ stays at 6
    30 & 8  = 8 â†’ moves to 14

After Resize:
    Bucket 6:  6 â†’ 22
    Bucket 14: 14 â†’ 30

----------------------------------------------------
8) CLASSIC COLLISION + RESIZE EXAMPLE (FROM VIDEO)
----------------------------------------------------
Keys:
    1, 9, 17

Initial Capacity = 8

Bucket Structure:
    Bucket 1: 1 â†’ 9 â†’ 17

Why collision?
    All keys map to same bucket.

After Resize (8 â†’ 16):

    1  & 15 = 1  â†’ Bucket 1
    9  & 15 = 9  â†’ Bucket 9
    17 & 15 = 1  â†’ Bucket 1

After Resize Buckets:
    Bucket 1:  1 â†’ 17
    Bucket 9:  9

Observations:
- Resize redistributes entries.
- Collisions may still exist.
- Resize reduces collisions but does NOT eliminate them.

----------------------------------------------------
9) INSERTION PROCESS (put)
----------------------------------------------------
1. Compute hashCode
2. Calculate index
3. If bucket empty â†’ insert
4. If bucket not empty:
    - Compare hash
    - If equals() true â†’ replace value
    - Else â†’ add new node
5. Check size > threshold
6. Resize if needed

----------------------------------------------------
10) RETRIEVAL PROCESS (get)
----------------------------------------------------
1. Compute hashCode
2. Calculate index
3. Go to bucket
4. Traverse list / tree
5. Use equals()
6. Return value

----------------------------------------------------
11) IMPORTANT FACTS
----------------------------------------------------
- Integer.hashCode(x) = x
- One bucket = ONE linked list (or tree)
- Collisions are NORMAL.
- No resize â†’ collisions remain.
- Resize â†’ collisions often reduce.

Time Complexity:
    Average: O(1)
    Worst: O(n) â†’ List
           O(log n) â†’ Tree

----------------------------------------------------
12) INTERVIEW MENTAL MODEL (MUST REMEMBER)
----------------------------------------------------
ðŸ‘‰ Resizing is triggered by SIZE, not collisions.
ðŸ‘‰ Resizing often reduces collisions.
ðŸ‘‰ Collisions may still remain after resize.
ðŸ‘‰ If resize does not happen, collisions stay.

----------------------------------------------------
13) INTERVIEW ONE-LINERS
----------------------------------------------------
- HashMap uses hashing + chaining.
- hashCode decides bucket, equals decides identity.
- Each bucket stores one linked list or tree.
- Resize happens at 75% capacity.
- Java 8 optimizes collisions using Red-Black Tree.